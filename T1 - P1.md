# TEMA 1 - CLASES MODULARES (Parte 1)
## **INTRODUCCIÓN A LAS CLASES MODULARES**

En programación existen **DOS TIPOS DE ABSTRACCIÓN**:
- **Abstracción funcional**: Encargar una respuesta o solución a una operacion independiente. En otras palabras, se implementa una nueva operación para resolver un problema.
- **Abstracción de datos**: Creación de un nuevo tipo de dato capaz de realizar operaciones internas que nos permitan construir, modificar o consultar elementos de este mismo dato.

Entonces, el proceso de abstracción nos permite definir modulos independientes de nuestro programa principal. 

En este capitulo trabajaremos con los *modulos de datos*, que definen un *tipo de dato* como un determinado dominio de valores y conjunto de operaciones. Estos datos los encapsularemos en modulos llamados **CLASES** que definen una estructura de *atributos* y operaciones llamadas *metodos*. Recuerda esta frase: *Cada objeto es propietario de sus atributos y metodos*.

Para crear una clase, cumpliremos las dos fases del diseño de los modulos:

1. **Fase de Especificación**: Supondremos la existencia de una representación y de unas operaciones para manipularla. Nos abstaeremos de las representaciones concretas, pero asumiremos el comportamiento de las operaciones. Dicho de otra manera, haremos una especificación del uso del tipo de datos, sin adentrarnos en el "como" se hará.
2. **Fase de Implementación**: Codificaremos las operaciones sobre esta representación sin que una futura modificación afecte a la especificación de esta.

En el siguiente apartado aprofundiremos en estas dos etapas, pero primero vamos a observar la notación de las classes en C++.

Hasta ahora, si queriamos consultar si una clase *Estudiante* tiene o no una nota con la función *tiene_nota()*, la codificabamos así:

```
/* Pre: cierto */
/* Post: el resultado indica si 'e' tiene nota */

bool tiene_nota(const Estudiant &e);
```

Ahora, haciendo uso de la orientación a objetos, la esribiremos así:
```
/* Pre: cierto */
/* Post: el resultado indica si el parametro implicito tiene nota */

bool tiene_nota() const
```

Que es el parametro implicito? Para responder esta pregunta, volveremos atras en estos apuntes. Recordais cuando hemos definido las clases que hemos enfatizado en recordar esta frase: '*Cada objeto es propietario de sus atributos y metodos*'? Bien, pues tal y como se describe, un objeto tiene sus propios metodos los cuales otros objetos no podrán hacer uso, ya que no serán el propietario.

En otras palabras, al crear una clase veremos que las funciones veremos que el objeto propietario de sus metodos no requiere de su aparicón explicita en la cabecera de una función. Entonces el objeto no es un parametro de un metodo, pero implicitamente se referirá a el.

Para llamar a un metodo de un objeto en concreto, lo haremos de la siguiente manera:
```
<nombre_del_objeto>.<nombre_del_metodo>(<otros_parametros>)
```

Siguiendo con el ejemplo, si quisieramos llamar la función previa, teniendo a *b* como variable booleana y *est* como un objeto creado en la clase *Estudiante*, pasaremos de ejecutarlo así:

```
b = tiene_nota(est);
```

a codificarlo de esta manera:

```
b = est.tiene_nota();
```

En el caso que se quiera modificar un objeto dentro de una clase, este debe tener un metodo que **NO** contenga el *const* en la especificación explicita de los parametros, como por ejemplo:

```
/* Pre: el parametro implicito tiene nota y "nota" es una nota valida */
/* Post: la nota del parametro implicito pasa a ser "nota" */

void modificar_nota(double nota);

int n = est.modificar_nota(x);
```